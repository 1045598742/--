# 总结

###### 什么是纯函数

```javascript
简单来说，一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用，我们就把这个函数叫做纯函数。这么说肯定比较抽象，我们把它掰开来看：

函数的返回结果只依赖于它的参数。
函数执行过程里面没有副作用。

const a = 1
const foo = (b) => a + b
foo(2) // => 3

foo 函数不是一个纯函数，因为它返回的结果依赖于外部变量 a

为什么要煞费苦心地构建纯函数？因为纯函数非常“靠谱”，执行一个纯函数你不用担心它会干什么坏事，它不会产生不可预料的行为，也不会对外部产生影响。不管何时何地，你给它什么它就会乖乖地吐出什么。如果你的应用程序大多数函数都是由纯函数组成，那么你的程序测试、调试起来会非常方便
```

###### this的典型应用

```javascript
1、纯粹函数调用。

function test() {
    this.x = 1;
    alert(x);
}
test();//其实这里的this就是全局变量。看下面的例子就能很好的理解其实this就是全局对象Global。

2.作为构造函数调用。所谓构造函数，就是生成一个新的对象。这时，这个this就是指这个对象
function test() {
    this.x = 1;
}
var o = new test();
alert(o.x);//1

3.apply或call调用
this指向的是apply中的第一个参数。

4.在html元素事件属性中使用
<input type=”button” onclick=”showInfo(this);” value=”点击一下”/>
    
5.事件处理函数点击，获取值    
    input type="button" id="text" value="点击一下" />
	<script type="text/javascript">
        var btn = document.getElementById("text");
        btn.onclick = function() {
            alert(this.value);    //此处的this是按钮元素
        }
	</script>
```

###### 什么是ajax

```
首先，speak with me, 诶债克斯，别读成阿贾克斯了哦~。

AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。

AJAX 不是新的编程语言，而是一种使用现有标准的新方法。

AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。

AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。

Ajax就是用 JS 发起一个请求，并得到服务器返回的内容。这跟以前的技术最大的不同点在于「页面没有刷新」，改善了用户体验，仅此而已。

1. 创建一个对象 XMLHttpRequest
var xhr = new XMLHttpRequest();为了支持ie6以及更早的版本，要 var xhr=new ActiveXObject()
2.监听请求成功后的状态变化
3.设置请求参数
4.发起请求
5.操作DOM，实现动态局部刷新

一个完整的请求由四部分组成

onreadystatechange：用来监听readyState的变化的

readyState：表示当前请求的后台的状态

status：表示处理的结果

其中readyState：表示当前请求的后台的状态

0：请求未初始化(还没有调用open())

1：请求已经建立，但是还没有发送(还没有调用send())

2：请求已经发送，正在处理中

3：请求正在处理中，通常响应中已经有部分数据可以用了

4：响应已经完成，可以获取并使用服务器的响应了

而status：表示处理的结果(状态码)

1XX，表示收到请求正在处理中

status == 200 是表示处理的结果是OK的

状态码:200到300是指服务端正常返回

304:如果网页自请求者上次请求后再也没有更改过，应将服务器配置为返回此响应，进而节省带宽和开销

404:找不到对象（404 not found)

503:服务器超时

设置请求参数

Get和post方法的区别：

get是获取数据，get的send方法的参数可以是null或者空，对发送信息有限制，一般在2000个字符，一般是用来查询（幂等） 
post可以发送数据，但是在使用post方法发送数据，需要使用setRequestHeader()来添加HTTP头，同时，post的send()方法需要写入要发送的数据的值, 一般用于修改服务器上的资源，对信息数量无限制，也更安全

ajax.open("post", "/carrots-admin-ajax/a/login",true);
ajax.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
ajax.send("name=" + name + "&pwd=" + code);
Content-type要作为请求头放在open和send之间
```

###### ajax的优缺点

```
总结——AJAX的优点与缺点：
优点：
1、实现了异步交互，提高了用户体验。
2、无需重新加载整个网页，只需要与服务器进行少量的数据交换，就能够实现对网页中的某一部分进行更新，从而减少了带宽的占用。
3、AJAX是在客户端运行的，它承载了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。
缺点：
1、安全性问题，大量的使用AJAX暴露了服务器交互的细节。
2、不容易调试。
3、对搜索引擎的支持比较弱。
```

###### web前端页面加载及性能优化

```html
一、减少HTTP请求

    上面说到80%~90%时间花在了下载页面中的所有组件进行的HTTP请求上。因此，改善响应时间最简单的途径就是减		少HTTP请求的数量。
    假设导航栏上有五幅图片，点击每张图片都会进入一个链接，这样五张导航的图片在加载时会产生5个HTTP请求。	然而，使用一个图片地图可以提高效率，这样就只需要一个HTTP请求。
    CSS Sprites直译过来就是CSS精灵，但是这种翻译显然是不够的，其实就是通过将多个图片融合到一副图里面，	然后通过CSS的一些技术布局到网页上。特别是图片特别多的网站，如果能用css sprites降低图片数量，带来的	将是速度的提升。

    字体图标
    在可以大量使用字体图标的地方我们可以尽可能使用字体图标，字体图标可以减少很多图片的使用，从而减少http	请求，字体图标还可以通过CSS来设置颜色、大小等样式，何乐而不为。
    合并脚本 和样式表
    将多个样式表或者脚本文件合并到一个文件中，可以减少HTTP请求的数量从而缩短效应时间。
    然而合并所有文件对许多人尤其是编写模块化代码的人来说是不能忍的，而且合并所有的样式文件或者脚本文件可	  能会导致在一个页面加载时加载了多于自己所需要的样式或者脚本，对于只访问该网站一个（或几个）页面的人来     说反而增加了下载量，所以大家应该自己权衡利弊。

二、使用CDN
        如果应用程序web服务器离用户更近，那么一个HTTP请求的响应时间将缩短。另一方面，如果组件web服务器    离用户更近，则多个HTTP请求的响应时间将缩短。

     CDN（内容发布网络）是一组分布在多个不同地理位置的Web服务器，用于更加有效地向用户发布内容。在优化性    能时，向特定用户发布内容的服务器的选择基于对网络慕课拥堵的测量。例如，CDN可能选择网络阶跃数最小的服务    器，或者具有最短响应时间的服务器。

    CDN还可以进行数据备份、扩展存储能力，进行缓存，同时有助于缓和Web流量峰值压力。
    CDN的缺点：
    1、响应时间可能会受到其他网站流量的影响。CDN服务提供商在其所有客户之间共享Web服务器组。
    2、如果CDN服务质量下降了，那么你的工作质量也将下降
    3、无法直接控制组件服务器

三、添加Expires头
    页面的初次访问者会进行很多HTTP请求，但是通过使用一个长久的Expires头，可以使这些组件被缓存，下次访问 	的时候，就可以减少不必要的HTPP请求，从而提高加载速度。

    Web服务器通过Expires头告诉客户端可以使用一个组件的当前副本，直到指定的时间为止。例如：
    Expires: Fri, 18 Mar 2016 07:41:53 GMT
    Expires缺点： 它要求服务器和客户端时钟严格同步；过期日期需要经常检查
    HTTP1.1中引入Cache-Control来克服Expires头的限制，使用max-age指定组件被缓存多久。
    Cache-Control： max-age=12345600
    若同时制定Cache-Control和Expires，则max-age将覆盖Expires头

四、压缩组件
    从HTTP1.1开始，Web客户端可以通过HTTP请求中的Accept-Encoding头来表示对压缩的支持
    Accept-Encoding: gzip,deflate
    如果Web服务器看到请求中有这个头，就会使用客户端列出来的方法中的一种来进行压缩。Web服务器通过响应中的    Content-Encoding来通知 Web客户端。
    Content-Encoding: gzip

    代理缓存
    当浏览器通过代理来发送请求时，情况会不一样。假设针对某个URL发送到代理的第一个请求来自于一个不支持       gzip的浏览器。这是代理的第一个请求，缓存为空。代理将请求转发给服务器。此时响应是未压缩的，代理缓存同     时发送给浏览器。现在，假设到达代理的请求是同一个url，来自于一个支持gzip的浏览器。代理会使用缓存中未     压缩的内容进行响应，从而失去了压缩的机会。相反，如果第一个浏览器支持gzip，第二个不支持，你们代理缓存     中的压缩版本将会提供给后续的浏览器，而不管它们是否支持gzip。

    解决办法：在web服务器的响应中添加vary头Web服务器可以告诉代理根据一个或多个请求头来改变缓存的响应。因              为压缩的决定是基于Accept-Encoding请求头的，因此需要在vary响应头中包含Accept-Encoding。

    vary: Accept-Encoding

五、将样式表放在头部
    首先说明一下，将样式表放在头部对于实际页面加载的时间并不能造成太大影响，但是这会减少页面首屏出现的时     间，使页面内容逐步呈现，改善用户体验，防止“白屏”。

    我们总是希望页面能够尽快显示内容，为用户提供可视化的回馈，这对网速慢的用户来说是很重要的。

    将样式表放在文档底部会阻止浏览器中的内容逐步出现。为了避免当样式变化时重绘页面元素，浏览器会阻塞内容     逐步呈现，造成“白屏”。这源自浏览器的行为：如果样式表仍在加载，构建呈现树就是一种浪费，因为所有样式表     加载解析完毕之前务虚会之任何东西

六、将脚本放在底部
    更样式表相同，脚本放在底部对于实际页面加载的时间并不能造成太大影响，但是这会减少页面首屏出现的时间，	  使页面内容逐步呈现

    js的下载和执行会阻塞Dom树的构建（严谨地说是中断了Dom树的更新），所以script标签放在首屏范围内的HTML	  代码段里会截断首屏的内容。

    下载脚本时并行下载是被禁用的——即使使用了不同的主机名，也不会启用其他的下载。因为脚本可能修改页面内		容，因此浏览器会等待；另外，也是为了保证脚本能够按照正确的顺序执行，因为后面的脚本可能与前面的脚本存	  在依赖关系，不按照顺序执行可能会产生错误。


七、避免CSS表达式
	CSS表达式是动态设置CSS属性的一种强大并且危险的方式，它受到了IE5以及之后版本、IE8之前版本的支持。
    p {
        width: expression(func(),document.body.clientWidth > 400 ? "400px" : "auto");
        height: 80px;
        border: 1px solid #f00;
    }
	鼠标移动了几次，函数的运行次数轻而易举的达到了几千次，危险性显而易见。
 
八、使用外部的JavaScript和CSS

    内联脚本或者样式可以减少HTTP请求，按理来说可以提高页面加载的速度。然而在实际情况中，当脚本或者样式是	从外部引入的文件，浏览器就有可能缓存它们，从而在以后加载的时候能够直接使用缓存，而HTML文档的大小减		小，从而提高加载速度。

    影响因素：

    1、每个用户产生的页面浏览量越少，内联脚本和样式的论据越强势。譬如一个用户每个月只访问你的网站一两次，	   那么这种情况下内联将会更好。而如果该用户能够产生很多页面浏览量，那么缓存的样式和脚本将会极大减少下	载的时间，提交页面加载速度。

    2、如果你的网站不同的页面之间使用的组件大致相同，那么使用外部文件可以提高这些组件的重用率。

    加载后下载

    有时候我们希望内联样式和脚本，但又可以为接下来的页面提供外部文件。那么我们可以在页面加载完成止呕动态     加载外部组件，以便用户接下来的访问。

九、减少DNS查找

    当我们在浏览器的地址栏输入网址（譬如： www.linux178.com） ，然后回车，回车这一瞬间到看到页面到底发     生了什么呢？

    域名解析 --> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求，浏览器得到		html代码 --> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --> 浏览器对页面进行 

    渲染呈现给用户
    DNS也是开销，通常浏览器查找一个给定域名的IP地址要花费20~120毫秒，在完成域名解析之前，浏览器不能从服		务器加载到任何东西。那么如何减少域名解析时间，加快页面加载速度呢？

    当客户端DNS缓存（浏览器和操作系统）缓存为空时，DNS查找的数量与要加载的Web页面中唯一主机名的数量相       同，包括页面URL、脚本、样式表、图片、Flash对象等的主机名。减少主机名的 数量就可以减少DNS查找的数量。

    减少唯一主机名的数量会潜在减少页面中并行下载的数量（HTTP 1.1规范建议从每个主机名并行下载两个组件，但	  实际上可以多个），这样减少主机名和并行下载的方案会产生矛盾，需要大家自己权衡。建议将组件放到至少两	     个但不多于4个主机名下，减少DNS查找的同时也允许高度并行下载。

十、精简JavaScript

    精简

    精简就是从代码中移除不必要的字符以减少文件大小，降低加载的时间。代码精简的时候会移除不必要的空白字符    （空格，换行、制表符），这样整个文件的大小就变小了。

    混淆

    混淆是应用在源代码上的另外一种方式，它会移除注释和空白符，同时它还会改写代码。在混淆的时候，函数和变     量名将会被转换成更短的字符串，这时代码会更加精炼同时难以阅读。通常这样做是为了增加对代码进行反向工程     的难度，这也同时提高了性能。

    缺点：

    混淆本身比较复杂，可能会引入错误。

    需要对不能改变的符号做标记，防止JavaScript符号（譬如关键字、保留字）被修改。

    混淆会使代码难以阅读，这使得在产品环境中调试问题更加困难。

    在以上提到了关于用gzip之类的压缩方式来压缩文件，这边说明一下，就算使用gzip等方式来压缩文件，精简代码     依然是有必要的。一般来说，压缩产生的节省是高于精简的，在生产环境中，精简和压缩同时使用能够最大限度的     获得更多的节省。

十一、避免重定向

    什么是重定向？

    重定向用于将用户从一个URL重新路由到另一个URL。

    常用重定向的类型

    301：永久重定向，主要用于当网站的域名发生变更之后，告诉搜索引擎域名已经变更了，应该把旧域名的的数据和	链接数转移到新域名下，从而不会让网站的排名因域名变更而受到影响。

    302：临时重定向，主要实现post请求后告知浏览器转移到新的URL。

    304：Not Modified，主要用于当浏览器在其缓存中保留了组件的一个副本，同时组件已经过期了，这是浏览器就     会生成一个条件GET请求，如果服务器的组件并没有修改过，则会返回304状态码，同时不携带主体，告知浏览器可     以重用这个副本，减少响应大小。

十二、删除重复脚本

    在团队开发一个项目时，由于不同开发者之间都可能会向页面中添加页面或组件，因此可能相同的脚本会被添加多	  次。

    重复的脚本会造成不必要的HTTP请求（如果没有缓存该脚本的话），并且执行多余的JavaScript浪费时间，还有     可能造成错误。

    如何避免重复脚本呢？

    1. 形成良好的脚本组织。重复脚本有可能出现在不同的脚本包含同一段脚本的情况，有些是必要的，但有些却不是     必要的，所以需要对脚本进行一个良好的组织。

    2. 实现脚本管理器模块。	

十三、配置ETag

    以前浏览器缓存的就会失效。

    什么是ETag？

    实体标签(EntityTag)是唯一标识了一个组件的一个特定版本的字符串，是web服务器用于确认缓存组件的有效性     的一种机制，通常可以使用组件的某些属性来构造它。

    条件GET请求

    如果组件过期了，浏览器在重用它之前必须首先检查它是否有效。浏览器将发送一个条件GET请求到服务器，服务器     判断缓存还有效，则发送一个304响应，告诉浏览器可以重用缓存组件。

    那么服务器是根据什么判断缓存是否还有效呢?有两种方式：

    ETag（实体标签）；

    最新修改日期；

    最新修改日期

    原始服务器通过Last-Modified响应头来返回组件的最新修改日期

十四、使Ajax可缓存
    异步与即时

    Ajax的一个明显的有点就是向用户提供了即时反馈，因为它异步的从后端web服务器请求信息。

    用户是否需要等待的关键因素在于Ajax请求是被动的还是主动的。被动请求是为了将来来使用而预先发起的，主动	请求是基于用户当前的操作而发起的

    什么样的AJAX请求可以被缓存？

    POST的请求，是不可以在客户端缓存的，每次请求都需要发送给服务器进行处理，每次都会返回状态码200。（可     以在服务器端对数据进行缓存，以便提高处理速度）

    GET的请求，是可以（而且默认）在客户端进行缓存的，除非指定了不同的地址，否则同一个地址的AJAX请求，不    会重复在服务器执行，而是返回304。

    Ajax请求使用缓存

    在进行Ajax请求的时候，可以选择尽量使用get方法，这样可以使用客户端的缓存，提高请求速度



参考文献：https://www.cnblogs.com/MarcoHan/p/5295398.html
```

###### get和post的请求区别

```
request获取请求参数
最为常见的客户端传递参数方式有两种：

浏览器地址栏直接输入：一定是GET请求；

超链接：一定是GET请求；

表单：可以是GET，也可以是POST，这取决与<form>的method属性值；

GET请求和POST请求的区别：

1.效率
GET的意思是『得』，从服务器获取数据（也可以上传数据，参数就是），效率较高
POST的意思是『给』，但可以向服务器发送数据和下载数据，效率不如GET
2.缓存
GET 请求能够被缓存，默认的请求方式也是有缓存的
POST请求默认不会缓存
缓存是针对URL来进行缓存的，GET请求由于其参数是直接加在URL上-的，一种参数组合就有一种URL的缓存，可以根据参数来进行一一对应，重复请求是幂等的（不论请求多少次，结果都一样）;
而POST请求的URL没有参数,每次请求的URL都相同，数据体（HTTPBody）可能不同，无法一一对应，所以缓存没有意义
3.安全性
GET的所有参数全部包装在URL中，明文显示，且服务器的访问日志会记录，非常不安全
POST的URL中只有资源路径，不包含参数，参数封装在二进制的数据体中，服务器也不会记录参数，相对安全。所有涉及用户隐私的数据都要用POST传输
POST的安全是相对的，对于普通用户来说他们看不到明文，数据封装对他们来说就是屏障。但是对于专业人士，它们会抓包会分析，没有加密的数据包对他们来说也是小case。所以POST仅仅是相对安全，唯有对数据进行加密才会更安全。当然加密也有被破解的可能性，理论上所有的加密方式都可以破解，只是时间长短的问题。而加密算法要做的就是使得破解需要的时间尽量长，越长越安全。由于我们也需要解密，加密算法太过复杂也并非好事，这就要结合使用情况进行折中或者足够实际使用即可。绕的有点远，具体的话，我将在后续的文章之中介提及，并介绍一些常用的加密算法。

4.数据量
HTTP协议中均没有对GET和POST请求的数据大小进行限制，但是实际应用中它们通常受限于软硬件平台的设计和性能。

GET：不同的浏览器和服务器不同，一般限制在2~8K之间，更加常见的是1k以内
POST方法提交的数据比较大，大小靠服务器的设定值限制，PHP默认是2M（具体的话大家以后看后端给的开发文档就行了）

post传送变化的数据显示，变动性访问；
get通过url地址传送数据，数据量不能超过1024byte；
post作为http消息的实体内容传送到服务器中，传送数据量可以很大；
get传送数据要经过encodeURIComponent编码，防止乱码。
get方式，服务器端用Request.QueryString获取变量的值；
post方式，服务器端用Request.Form获取提交的数据
```

###### get和post的使用场景

```
GET和POST两种方法都是将数据送到服务器。HTTP标准包含这两种方法是为了达到不同的目的。

POST用于创建资源，资源的内容会被编入HTTP请示的内容中。例如，处理订货表单、在数据库中加入新数据行等。

当请求无副作用时（如进行搜索），便可使用GET方法；当请求有副作用时（如添加数据行），则用POST方法。一个比较实际的问题是：GET方法可能会产生很长的URL，或许会超过某些浏览器与服务器对URL长度的限制。

若符合下列任一情况，则用POST方法：

* 请求的结果有持续性的副作用，例如，数据库内添加新的数据行。
* 若使用GET方法，则表单上收集的数据可能让URL过长。
* 要传送的数据不是采用7位的ASCII编码。

若符合下列任一情况，则用GET方法：

* 请求是为了查找资源，HTML表单数据仅用来帮助搜索。
* 请求结果无持续性的副作用。
* 收集的数据及HTML表单内的输入字段名称的总长不超过1024个字符。
```

###### 前端优化调试工具

```
https://www.jianshu.com/p/b63e6b7df8bf 自己看
```

###### 什么是sql注入，xss攻击

```
所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意的）SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。比如先前的很多影视网站泄露VIP会员密码大多就是通过WEB表单递交查询字符暴出的，这类表单特别容易受到SQL注入式攻击．

https://blog.csdn.net/ideality_hunter/article/details/80623526

XSS攻击全称跨站脚本攻击，是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。

预防xss
1、编码，就是转义用户的输入，把用户的输入解读为数据而不是代码
2、校验，对用户的输入及请求都进行过滤检查，如对特殊字符进行过滤，设置输入域的匹配规则等
```

###### 判断js变量是不是数组

```
方法一： 使用instanceof方法
console.log(arr instanceof Array) //返回true

方法二： 使用constructor方法
console.log([].constructor == Array);  //true

方法三： 使用Object.prototype.toString.call(arr) === '[object Array]'方法

方法四：ES5定义了Array.isArray:
Array.isArray([]) //true
```

###### HTTP状态消息200 302 304 403 404 500分别表示什么

```
200：请求已成功，请求所希望的响应头或数据体将随此响应返回。

302：请求的资源临时从不同的 URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的

304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。

403：服务器已经理解请求，但是拒绝执行它。

404：请求失败，请求所希望得到的资源未被在服务器上发现。

500：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。
```

###### HTTP协议中，header信息里面，怎么控制页面失效时间（last-modified,cache-control,Expires分别代表什么）

| Last-Modified | 文 档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档 才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。 |
| ------------- | ------------------------------------------------------------ |
| Expires       | 应该在什么时候认为文档已经过期，从而不再缓存它？             |

###### 列举常用的js框架以及分别适用的领域

```
jquery：简化了js的一些操作，并且提供了一些非常好用的API

jquery ui、jquery-easyui：在jqeury的基础上提供了一些常用的组件 日期，下拉框，表格这些组件

require.js、sea.js（阿里的玉帛）+》模块化开发使用的

jquery mobile：是jquery自己出的支持移动端网页开发，不过非常笨重，但是功能非常强大

zepto：精简版的jquery，常用于手机web前端开发 提供了一些手机页面实用功能,touch

ext.js：跟jquery差不多，但是不开源，也没有jquery轻量

angular、knockoutjs、avalon(去哪儿前端总监，作者：司徒正美)：MV*框架，适合用于单页应用开发(SPA)

Vue.js（读音 /vjuː/, 类似于view）是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用。简单小巧的核心，渐进式技术栈，足以应付任何规模的应用。

react 是一个用于构建用户界面的 JAVASCRIPT 库。
React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。
React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。
React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。
React 特点
1.声明式设计 −React采用声明范式，可以轻松描述应用。
2.高效 −React通过对DOM的模拟，最大限度地减少与DOM的交互。
3.灵活 −React可以与已知的库或框架很好地配合。
4.JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。
5.组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。
6.单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。
JSX就是Javascript和XML结合的一种格式。React发明了JSX，利用HTML语法来创建虚拟DOM。当遇到<，JSX就当HTML解析，遇到{就当JavaScript解析。
```

###### 有1到10w这个10w个数，去除2个并打乱次序，如何找出那两个数

```javascript
var arrA = [];
        var arrB = [];
        var arrC = [];
        
        //求出A数组的值
        for(var i = 0; i < 10000; i++) {
            arrA.push(i);
        }
        //A排序
        arrA.sort(function(a, b) {
            return Math.random() - 0.5
        })
        console.log(arrA)
        //求出B数组的值
        for(var i = 0; i < arrA.length - 2; i++) {
            arrB[arrA[i]] = arrA[i];
            //console.log(arrB);
        
        }　　　//如果B数组里的第i项为undefind，打印出i放在arrC
        for(var i = 0; i<arrA.length; i++){
            if(arrB[i] == undefined){
                arrC.push(i);
                if(arrC.length==2){
                    break
                }
            }
        }
        console.log(arrC);
```

###### JS继承的六种方式

```
// 父类
function Super(){
  this.property = 'Super Property'
}
Super.prototype.getProperty = function(){
  return this.property
}

一.构造继承
function Sub(){
  Super.call(this)
  this.property = 'Sub Property'
}

二.原型链继承
// 子类
function Sub(){
  this.property = 'Sub Property'
}
Sub.prototype = new Super()
// 注意这里new Super()生成的超类对象并没有constructor属性,故需添加上
Sub.prototype.constructor = Sub

三.组合继承
// 子类
function Sub(){
  Super.call(this)
  this.property = 'Sub Property'
}
Sub.prototype = new Super()
// 注意这里new Super()生成的超类对象并没有constructor属性,故需添加上
Sub.prototype.constructor = Sub

四.原型式继承
function objectCreate(obj){
  function F(){}
  F.prototype = obj
  return new F()
}

五.寄生式继承
function objectCreate(obj){
  function F(){}
  F.prototype = obj
  return new F()
}
function createSubObj(superInstance){
  var clone = objectCreate(superInstance)
  clone.property = 'Sub Property'
  return clone
}

六.寄生组合式继承
function inheritPrototype(Super,Sub){
  var superProtoClone = Object.Create(Super.prototype)
  superProtoClone.constructor = Sub
  Sub.prototype = Super
}
function Sub(){
  Super.call()
  Sub.property = 'Sub Property'
}
inheritPrototype(Super,Sub)
```

###### 实现html的bfc

```html
  <style>
     .column:nth-of-type(1) {
            float: left;
            width: 200px;
            height: 300px;
            margin-right: 10px;
            background-color: red;
        }
        
        .column:nth-of-type(2) {
            overflow: hidden;/*创建bfc */
            height: 300px;
            background-color: purple;
        }
    </style>
    <!-- <script src="./js/require.js" type="text/javascript" defer async='true' data-main='../dist/main-build.js'></script> -->
<body>
    <div class="column"></div>
    <div class="column"></div>
</body>
```

###### http请求的几种方式

```
HTTP/1.1协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源：
OPTIONS：
这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用'*'来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。

HEAD：
与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。

GET：
向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。参见安全方法

POST：
向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。

PUT：
向指定资源位置上传其最新内容。

DELETE：
请求服务器删除Request-URI所标识的资源。

TRACE：
回显服务器收到的请求，主要用于测试或诊断。

CONNECT：
HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。
方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。
通常我们用的也都是 GET 和 POST 方法，如果要实现其他的方法，需要在服务器做相应的配置。
但是我们应该清楚，有这些个动作的存在。
而且，其他请求方式也都可以通过这两种方式间接的来实现。

链接：https://www.jianshu.com/p/562aa3baa9b8
```

###### 面向对象的三大基本特征

```
1.封装

封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。
封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

2.继承

面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。
通过继承创建的新类称为“子类”或“派生类”。
被继承的类称为“基类”、“父类”或“超类”。
继承的过程，就是从一般到特殊的过程。
要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。
在某些 OOP 语言中，一个子类可以继承多个基类。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。
 
继承概念的实现方式有三类：实现继承、接口继承和可视继承。
Ø         实现继承是指使用基类的属性和方法而无需额外编码的能力；
Ø         接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；
Ø         可视继承是指子窗体（类）使用基窗体（类）的外观和实现代码的能力。
在考虑使用继承时，有一点需要注意，那就是两个类之间的关系应该是“属于”关系。例如，Employee 是一个人，Manager 也是一个人，因此这两个类都可以继承 Person 类。但是 Leg 类却不能继承 Person 类，因为腿并不是一个人。
抽象类仅定义将由子类创建的一般属性和方法，创建抽象类时，请使用关键字 Interface 而不是 Class。
OO开发范式大致为：划分对象→抽象类→将类组织成为层次化结构(继承和合成) →用类与实例进行设计和实现几个阶段。
 
3.多态
 
多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。
实现多态，有二种方式，覆盖，重载。
覆盖，是指子类重新定义父类的虚函数的做法。
重载，是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。
```

```
面向对象的基本特征

      1.封装

　　　　简单来讲: 将现实世界的事物抽象成计算机领域中的对象,对象同时具有属性和行为,这种抽象就是封装.

　　　　封装的一个重要特性: 数据隐藏. 对象只对外提供与其它对象交互的必要接口,而将自身的某些属性和实现细节对外隐藏,

　　　　通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。

　　　　这样就在确保正常交互的前提下,保证了安全性.

      2.继承

　　　　面向对象的一个重要特性是复用性.继承是实现复用性的一个重要手段.

　　　　可以在不重复编写以实现的功能的前提下,对功能进行复用和拓展.

　　　　继承概念的实现方式有二类：实现继承与接口继承。

　　　　　　*实现继承是指直接使用基类的属性和方法而无需额外编码的能力

　　　　　　*接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力

      3.多态

　　　　当存在继承关系时,允许将父类对象看成为和它的一个或多个子类对象等同.

　　　　这样,可以根据当前赋给父类对象的子对象的具体特性以不同的方式进行运行.

 　　　　多态的几个前提

　　　　　　* a:要有继承关系。

　　　　　　* b:要有方法重写。

　　　　　　* c:要有父类引用指向子类对象。

        　　多态的好处

　　　　　　* a:提高了代码的维护性(继承保证)

　　　　　　* b:提高了代码的扩展性(由多态保证)

　　　　多态的限制

          　　  * 不能使用子类的特有属性和行为。

五大基本原则 
单一职责原则SRP(Single Responsibility Principle)
　　是指一个类的功能要单一，不能包罗万象。

开放封闭原则OCP(Open－Close Principle) 
　　一个模块在扩展性方面应该是开放的,而在更改性方面应该是封闭的。

　　比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能，那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码

　　这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来。

替换原则(the Liskov Substitution Principle LSP) 
　　子类应当可以替换父类并出现在父类能够出现的任何地方。

　　比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工，也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了。

依赖原则(the Dependency Inversion Principle DIP)

　　具体依赖抽象，上层依赖下层。

　　假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类： 而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：　　这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。

　　通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。　　

接口分离原则(the Interface Segregation Principle ISP) 
　　模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来
```

###### 什么是面向对象

```
面向对象是一种思想，是基于面向过程而言的，就是说面向对象是将功能等通过对象来实现，将功能封装进对象之中，让对象去实现具体的细节；这种思想是将数据作为第一位，而方法或者说是算法作为其次，这是对数据一种优化，操作起来更加的方便，简化了过程。面向对象有三大特征：封装性、继承性、多态性，其中封装性指的是隐藏了对象的属性和实现细节，仅对外提供公共的访问方式，这样就隔离了具体的变化，便于使用，提高了复用性和安全性。对于继承性，就是两种事物间存在着一定的所属关系，那么继承的类就可以从被继承的类中获得一些属性和方法；这就提高了代码的复用性。继承是作为多态的前提的。多态是说父类或接口的引用指向了子类对象，这就提高了程序的扩展性，也就是说只要实现或继承了同一个接口或类，那么就可以使用父类中相应的方法，提高程序扩展性，但是多态有一点不好之处在于：父类引用不能访问子类中的成员。

举例来说：就是：比如说你要去饭店吃饭，你只需要饭店，找到饭店的服务员，跟她说你要吃什么，然后就会给你做出来让你吃，你并不需要知道这个饭是怎么错做的，你只需要面向这个服务员，告诉他你要吃什么，然后他也只需要面向你吃完收到钱就好，不需要知道你怎么对这个饭进行吃。

1、特点：

1：将复杂的事情简单化。

2：面向对象将以前的过程中的执行者，变成了指挥者。

3：面向对象这种思想是符合现在人们思考习惯的一种思想。

2、面向对象的三大特征：封装，继承、多态

1.封装：只隐藏对象的属性和实现细节，仅对外提供公共访问方式

好处：将变化隔离、便于使用、提高复用性、提高安全性

原则：将不需要对外提供的内容隐藏起来；把属性隐藏，提供公共方法对其访问

2.继承：提高代码复用性；继承是多态的前提

注：

①子类中所有的构造函数都会默认访问父类中的空参数的构造函数，默认第一行有super()；若无空参数构造函数，子类中需指定；另外，子类构造函数中可自己用this指定自身的其他构造函数。

3.多态

是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象

好处：提高了程序的扩展性

弊端：当父类引用指向子类对象时，虽提高了扩展性，但只能访问父类中具备的方法，不可访问子类中的方法；即访问的局限性。

前提：实现或继承关系；覆写父类方法。
--------------------- 
作者：史努比程序媛 
来源：CSDN 
原文：https://blog.csdn.net/chenqiuping_ls/article/details/53609807 
版权声明：本文为博主原创文章，转载请附上博文链接！
```

###### 什么是闭包

```
3、闭包的概念

上面代码中的f2函数，就是闭包。

各种专业文献的闭包定义都非常抽象，我的理解是: 闭包就是能够读取其他函数内部变量的函数。

由于在javascript中，只有函数内部的子函数才能读取局部变量，所以说，闭包可以简单理解成“定义在一个函数内部的函数“。

所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁。

 4、闭包的用途

闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，不会在f1调用后被自动清除。

为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。

这段代码中另一个值得注意的地方，就是"nAdd=function(){n+=1}"这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。

5、使用闭包的注意点

（1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。

（2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。
```

###### Promise介绍

```javascript
promise是es6的语法
Promise 对象代表了未来将要发生的事件，用来传递异步操作的消息。

Promise 对象有以下两个特点:

1、对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：

pending: 初始状态，不是成功或失败状态。
fulfilled: 意味着操作成功完成。
rejected: 意味着操作失败。

只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段无法改变。

2、一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。



 function get(src){
            return new Promise((res,err)=>{
                let img = new Image()
                img.src=src
                img.onload = function(e){
                    res(img)
                };
                img.onerr = function(e){
                    err('错误')
                }
            })
        }

        // get('img.jpg').then(function(img){
        //     console.log(img)
        // },function(err){
        //     console.log(err)
        // })

        get('img.jpg').then(function(img){//链式加载
            console.log(img)
            return get('img1.jpg')
        }).then(function(img){
            console.log(img)
            return get('img2.jpg')
        }).then(function(img){
            console.log(img)
            return get('img3.jpg')
        })

        Promise.all([get('img.jgp'),get('img1.jgp'),get('img2.jgp')]).then(function(list){
            console.log(list) //all方法将所有执行完的一起返回回来数组
        })

        Promise.race([get('img.jgp'),get('img1.jgp'),get('img2.jgp')]).then(function(list){
            console.log(list) //race方法是返回先执行完的那个
        })
        Promise 优缺点

        有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，           Promise 对象提供统一的接口，使得控制异步操作更加容易。

        Promise 也有一些缺点。首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。其次，如果		   不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 Pending 状态时，无法得知目         前进展到哪一个阶段（刚刚开始还是即将完成）。
```

###### 防抖和节流

```javascript
function fn(callback,time){
            var a = null
            return function(){
                clearInterval(a);
                a = setTimeout(callback,time)
            }
        }

        window.onscroll = fn(function(){
            console.log('执行了')
        },500)

------------------------------上面是防抖，下面是节流--------------------------------------
        function fn(callback,time){
            var lasttime = new Date().getTime()
            return function(){
                var newtime = new Date().getTime()
                if(newtime-lasttime>500){
                    callback();
                    lasttime = newtime
                }
            }
        }

        window.onscroll = fn(function(){
            console.log('执行了')
        })
        
```

###### Es6  Set方法数组去重

```javascript
[...new Set(array)]

// 例一
const set = new Set([1, 2, 3, 4, 4]);
[...set]
// [1, 2, 3, 4]

// 例二
const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
items.size // 5

// 例三
const set = new Set(document.querySelectorAll('div'));
set.size // 56

set实例属性和方法

        size: 返回Set实例的成员总数。
        add(value)：添加某个值，返回 Set 结构本身。
        delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
        has(value)：返回一个布尔值，表示该值是否为Set的成员。
        clear()：清除所有成员，没有返回值。
--------------------- 
作者：xuxu_qkz 
来源：CSDN 
原文：https://blog.csdn.net/xuxu_qkz/article/details/80998141 
版权声明：本文为博主原创文章，转载请附上博文链接！
```

###### 深拷贝

```javascript
    var oldobj = {
            a:1,
            b:2,
            c:3,
            d:{
                d1:'d1',
                d2:"d2",
                set f(value){this.a=value},
                get f(){return this.a}
            },
            arr:[1,2,3,4,5],
        }
        Object.defineProperty(oldobj,'h',{value:10})


        var newobj = {}

        cloneObj(newobj,oldobj)
        function cloneObj(target,source){
            var names = Object.getOwnPropertyNames(source);//是oldobj的最外层的每一项的属性名 ["a", "b", "c", "d", "arr", "h"]
            for(var i=0;i<names.length;i++){
                var desc = Object.getOwnPropertyDescriptor(source,names[i])
                console.log(desc) 
                        // configurable : desc.configurable,
                        // enumerable : desc.enumerable,
                        // value : obj,
                        // writable : desc.writable
                if(typeof(desc.value)==='object' && desc.value !== null){
                    var obj;
                    if(Array.isArray(desc.value)){
                        obj = []
                    }else{
                        obj = {}
                    }
                    Object.defineProperty(target,names[i],{
                        configurable : desc.configurable, //不可删除
                        enumerable : desc.enumerable,//是否可遍历
                        value : obj,//值
                        writable : desc.writable//是否可修改
                    });
                    cloneObj(obj,desc.value)
                }else{
                    Object.defineProperty(target,names[i],desc)
                }
            }
        }
```

###### Proxy（代理）

```javascript
 var obj = {a:1,b:2}
        var handler = {
            set : function(target,key,value){
                console.log('这里设置了属性')
                target[key] = value;
            },
            get : function(target,key){
                console.log('这里获取了属性')
                return target[key]
            },
            has : function(target,key){
                console.log('这里判断了属性')//true 或 false
                return key in target
            }
        }
        
        var p = new Proxy(obj,handler)
        p.c = 20,
        console.log('b' in p)//true
        console.log({...p})
```

###### window.onload与$(window).ready区别

```javascript
两者都是加载后执行
html加载顺序:
	html结构
	加载外部样式表和执行文件
	解析执行脚本代码
	构造Dom模型（样式应用）//这里ready就开始执行
	加载图片文件等
	页面加载完毕
```

###### 事件循环EventLoop

```javascript
代码的执行顺序
	//js是事件驱动，因此最底层都是以事件驱动完成函数的毁掉执行，例如当有触发某个事件的启动因素时，就会抛出事件，调用回调函数，但这个过程并不是函数可以自己去回调，而是抛出事件后，将在任务列中等待下一个执行时间立即调用函数
//即使在同一个任务队列中俄又先后顺序，主要分宏观任务和微观任务

宏观任务 : setTimeout ， setInterval
微观任务 : process,nextTick,Promise

微观任务一般是在当前任务的尾部，下一次任务执行时间之前执行

宏观任务一般是在当前任务的尾部抛出事件，等待下一次任务队列执行时间开始的时候执行

这样任务队列就在一个个时间段内不停的循环执行下去
```

###### 当前样式预编译stylus

```javascript
http://stylus-lang.com/0
和sass的区别
去掉了花括号，选择器后面需要换行首行缩进，逗号分隔，

body
  font: 12px Helvetica, Arial, sans-serif

a.button
  -webkit-border-radius: 5px
  -moz-border-radius: 5px
  border-radius: 5px
```

###### 项目介绍

```
周期  项目描述 项目职责 项目技术栈 

兼容问题 css3样式 解决方案 ：样式处理文件 pie.htc
盒模型
margintop失效
选择器权重
移动端布局方式 ：rem加弹性盒
bootstarp：3.0是使用媒体查询 4.0是弹性盒布局 最好的pc布局方式
移动端兼容：meta标签
事件兼容哪些
h5新特性语义标签：
html5新增特性：  拖拽 https://www.cnblogs.com/ijjyo/p/4300717.html
                本地存储
                canvans
                websocket
                webwork：开辟短暂多线程
                前端可视化：
modole.exports：common.js应用模块的导出
export：批量导出
export defaule：只导出一个
在什么地方使用闭包：模块化就是特殊的闭包：插件封装(匿名函数就是闭包)
解决跨域：jsonp，window.open，iframe，cors，proxy反向代理
事件代理：jq低版本使用$.delegate() 现在都是on（）
vue双向数据绑定原理
vue3.0：vue.config（）配置
react和js最大的特点:函数式编程
react性能优化：shouldcommpontntupdate()
typescript:底层是js，加了java 类 断言等一些后端的java概念
```

###### vue2.0钩子函数

![1550249722986](C:\Users\Administrator.WIN7-1807141708\Desktop\react\1550249722986.png)

```
全局钩子函数之   全局的beforeEach钩子
组件内的钩子函数：（ beforeRouteEnter 和 beforeRouteLeave 再加一个 watch函数 ）
路由内：beforeEnter；afterrouter
路由的切换分为三个阶段：可重用阶段，验证阶段和激活阶段
```

###### react容器组件

```
它只负责显示，没有钩子函数，没有state，性能高于常规组件
二号位坚决不能使用setstate，会造成栈溢出
this.setstate（{}，()=>{}）它是异步的，第二个参数是一个回调
最损耗性能的钩子函数是render
注意componentReciveProps钩子只有存在父子组件关系的时候才会调用，并且是在子组件里面
react生态环境好，团队力量强大，pc端，移动端，微信项目，桌面项目，更简单
```

###### react生命周期

![1550258894649](C:\Users\Administrator.WIN7-1807141708\Desktop\react\1550258894649.png)

![1550258927787](C:\Users\Administrator.WIN7-1807141708\Desktop\react\1550258927787.png)

![1550259175241](C:\Users\Administrator.WIN7-1807141708\Desktop\react\1550259175241.png)

###### 有了react，vue，为什么还要jquery

```
一、jQuery对新人很友好，不需要理解很多的思想、理论、模式。拿过来就可以用，用了就可以出效果，很有学习的成就感。

二、jQuery很符合人的自然思维方式，也就是面向过程的思维方式。从a->b，再从b->c，再从c->d，一步一步的做下去。

三、jQuery很容易积累一些代码，因为按现在的标准来看，jq的代码的冗余量很大的。但是对于前端新人来讲，这是一个必须的过程，你必须多写代码，才能少写代码。

四、jQ因为没有MVVM的数据<->视图的对应关系，所以必须手动去维护数据与视图的一致性，所以对于前端新人的逻辑思维会有比较好的锻炼作用。当他切换到reactJs或是VueJs的时候，“dom查找器”和“MVVM数据驱动视图”这二种不同思维之间的对比会很强烈，会很明显的感受到reactJs和vueJs比jQuery先进在哪些。
```

为什么淘宝，天猫，京东不用react

```
因为电商业务很复杂，更新非常频繁，总不能搞一次活动让大家更新下app吧。
只是他们的技术实力比较强，自己研发，定制的比较深度，并不像小团队，直接用开源的框架做做
```

###### 什么是单页面应用

```javascript
//单页应用，是指将用户视觉上的多个页面在技术上使用一个载体来实现的应用。

换句话来讲，用户视觉效果，与技术实现的载体，并不是一定要一一对应的。采取哪种技术方案，取决于产品设计、技术组成以及方案之间的优劣平衡。
放到 Web 前端环境中，这个承载了多个视觉效果的载体，就是 html 文件（或 asp，jsp 等）

//单页应用的优点与缺点
相比传统的开发方式，单页应用有如下几方面的显著优点：

页面切换速度快。视觉上页面的切换，只是技术上同一页面两个区块之间的切换
页面之间的可传递所有js支持的数据类型，甚至是一个DOM元素
可为页面切换过程添加转场动画
与此同时，单页应用也存在如下几方面的缺点：

所有页面的样式、DOM和JS需要完全加载
页面打开速度稍慢
对于缺点1，开发者可借助如下手段解决或优化：

借助gulp.js等构建工具，将所有视图的样式、DOM结构和脚本分别合并之单独的文件中压缩，以降低影响。以复杂类型中等的电商为例，如果一个界面含有80个视图，那么通过构建工具合并压缩之后的脚本也只有1.1M左右

拆解客户端功能，仅将共属于同一操作范畴的视图构建至同一html中。不同操作范畴的视图隶属于不同html文件
对于缺点2，开发者可以通过配置web服务器，为页面加上缓存控制，从而降低影响，使得页面的第二次及其后的加载速度更快

```

###### 代码合并压缩工具

```
gulp，webpack，grunt,yarn
```

原型链

![1550278344611](C:\Users\Administrator.WIN7-1807141708\Desktop\react\1550278344611.png)

```javascript
什么叫原型链
答：实例对象与原型之间的连接
//Object.prototype下面有两员大将---Object和Function
Array instanceof Function //true 因为没有new 所以不是对象
```

###### jquery

```javascript
$.getJSON("http://www.runoob.com/try/ajax/jsonp.php?jsoncallback=?", function(data) {
    
    var html = '<ul>';
    for(var i = 0; i < data.length; i++)
    {
        html += '<li>' + data[i] + '</li>';
    }
    html += '</ul>';
    
    $('#divCustomers').html(html); 
});

$("p").remove(".italic");jQuery remove() 方法也可接受一个参数，允许您对被删元素进行过滤。
$("#div1").empty(); jQuery empty() 方法删除被选元素的子元素。
jQuery append() 方法在被选元素的结尾插入内容（仍然该元素的内部）。
jQuery prepend() 方法在被选元素的开头插入内容。
jQuery after() 方法在被选元素之后插入内容。
jQuery before() 方法在被选元素之前插入内容。
$("p").replaceWith("<b>Hello world!</b>");替换元素
```

###### json的了解

```
JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。

JSON 是 JS 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。
```

###### Axios发送请求时params和data的区别

```javascript
在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。 

因为params是添加到url的请求字符串中的，用于get请求。 

而data是添加到请求体（body）中的， 用于post请求。


//下面是axios参数代码

{
  // `url` 是请求的接口地址
  url: '/user',

  // `method` 是请求的方法
  method: 'get', // 默认值

  // 如果url不是绝对路径，那么会将baseURL和url拼接作为请求的接口地址
  // 用来区分不同环境，建议使用
  baseURL: 'https://some-domain.com/api/',

  // 用于请求之前对请求数据进行操作
  // 只用当请求方法为‘PUT’，‘POST’和‘PATCH’时可用
  // 最后一个函数需return出相应数据
  // 可以修改headers
  transformRequest: [function (data, headers) {
    // 可以对data做任何操作

    return data;
  }],

  // 用于对相应数据进行处理
  // 它会通过then或者catch
  transformResponse: [function (data) {
    // 可以对data做任何操作

    return data;
  }],

  // `headers` are custom headers to be sent
  headers: {'X-Requested-With': 'XMLHttpRequest'},

  // URL参数
  // 必须是一个纯对象或者 URL参数对象
  params: {
    ID: 12345
  },

  // 是一个可选的函数负责序列化`params`
  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)
  paramsSerializer: function(params) {
    return Qs.stringify(params, {arrayFormat: 'brackets'})
  },

  // 请求体数据
  // 只有当请求方法为'PUT', 'POST',和'PATCH'时可用
  // 当没有设置`transformRequest`时，必须是以下几种格式
  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams
  // - Browser only: FormData, File, Blob
  // - Node only: Stream, Buffer
  data: {
    firstName: 'Fred'
  },

  // 请求超时时间（毫秒）
  timeout: 1000,

  // 是否携带cookie信息
  withCredentials: false, // default

  // 统一处理request让测试更加容易
  // 返回一个promise并提供一个可用的response
  // 其实我并不知道这个是干嘛的！！！！
  // (see lib/adapters/README.md).
  adapter: function (config) {
    /* ... */
  },

  // `auth` indicates that HTTP Basic auth should be used, and supplies credentials.
  // This will set an `Authorization` header, overwriting any existing
  // `Authorization` custom headers you have set using `headers`.
  auth: {
    username: 'janedoe',
    password: 's00pers3cret'
  },

  // 响应格式
  // 可选项 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'
  responseType: 'json', // 默认值是json

  // `xsrfCookieName` is the name of the cookie to use as a value for xsrf token
  xsrfCookieName: 'XSRF-TOKEN', // default

  // `xsrfHeaderName` is the name of the http header that carries the xsrf token value
  xsrfHeaderName: 'X-XSRF-TOKEN', // default

  // 处理上传进度事件
  onUploadProgress: function (progressEvent) {
    // Do whatever you want with the native progress event
  },

  // 处理下载进度事件
  onDownloadProgress: function (progressEvent) {
    // Do whatever you want with the native progress event
  },

  // 设置http响应内容的最大长度
  maxContentLength: 2000,

  // 定义可获得的http响应状态码
  // return true、设置为null或者undefined，promise将resolved,否则将rejected
  validateStatus: function (status) {
    return status >= 200 && status < 300; // default
  },

  // `maxRedirects` defines the maximum number of redirects to follow in node.js.
  // If set to 0, no redirects will be followed.
  // 最大重定向次数？没用过不清楚
  maxRedirects: 5, // default

  // `httpAgent` and `httpsAgent` define a custom agent to be used when performing http
  // and https requests, respectively, in node.js. This allows options to be added like
  // `keepAlive` that are not enabled by default.
  httpAgent: new http.Agent({ keepAlive: true }),
  httpsAgent: new https.Agent({ keepAlive: true }),

  // 'proxy' defines the hostname and port of the proxy server
  // Use `false` to disable proxies, ignoring environment variables.
  // `auth` indicates that HTTP Basic auth should be used to connect to the proxy, and
  // supplies credentials.
  // This will set an `Proxy-Authorization` header, overwriting any existing
  // `Proxy-Authorization` custom headers you have set using `headers`.
  // 代理
  proxy: {
    host: '127.0.0.1',
    port: 9000,
    auth: {
      username: 'mikeymike',
      password: 'rapunz3l'
    }
  },

  // `cancelToken` specifies a cancel token that can be used to cancel the request
  // (see Cancellation section below for details)
  // 用于取消请求？又是一个不知道怎么用的配置项
  cancelToken: new CancelToken(function (cancel) {
  })
}
```

###### 清除浮动的几种方式

```css
1. .clearfloat:after{display:block;clear:both;content:"";visibility:hidden;height:0}
2.在结尾处添加空div标签 clear:both
3.父级div定义height
4.父级div定义overflow:hidden
5.父级div定义overflow:auto

6.父级div也一起浮动
7.父级div定义display:table
8、结尾处加br标签clear:both
```

###### Vue路由懒加载

```javascript
import Home from './components/Home.vue';
import Header from './components/Header.vue';

const User = resolve => {
	require.ensure(['./components/user/User.vue'],()=>{
		resolve(require('./components/user/User.vue'));
	});
}


const UserStart = resolve => {
	require.ensure(['./components/user/UserStart.vue'],()=>{
		resolve(require('./components/user/UserStart.vue'));
	});
}


const UserEdit = resolve => {
	require.ensure(['./components/user/UserEdit.vue'],()=>{
		resolve(require('./components/user/UserEdit.vue'));
	});
}


const UserDetail = resolve => {
	require.ensure(['./components/user/UserDetail.vue'],()=>{
		resolve(require('./components/user/UserDetail.vue'));
	});
}

component:()=>import(/* webpackChunkName: "one" */ '../src/components/two')

// 需要注意，没有加'user'参数，则把js给各个拆分加载，如果加了'user'，则都会集成在目标的模块中
/*
const User = resolve => {
	require.ensure(['./components/user/User.vue'],()=>{
		resolve(require('./components/user/User.vue'));
	},'user');
}


const UserStart = resolve => {
	require.ensure(['./components/user/UserStart.vue'],()=>{
		resolve(require('./components/user/UserStart.vue'));
	},'user');
}


const UserEdit = resolve => {
	require.ensure(['./components/user/UserEdit.vue'],()=>{
		resolve(require('./components/user/UserEdit.vue'));
	},'user');
}


const UserDetail = resolve => {
	require.ensure(['./components/user/UserDetail.vue'],()=>{
		resolve(require('./components/user/UserDetail.vue'));
	},'user');
}
*/

export const routes = [
	{ path:'',components:{ //需要注意的是原来的component变成了components，复数
		default:Home,
		'header-top':Header
		//,'header-bottom':Header //如果加上header-bottom，那就上下都会有显示头部内容了，所以router-view部分是有定义则显示，没定义则不显示的原则
	},name:'home' },
	{ path:'/user',components:{
		default:User,
		'header-bottom':Header
	},children:[
			{path:'',component:UserStart},
			{path:':id',component:UserDetail, beforeEnter:(to,from,next)=>{
				console.log('inside route setup');
				next();
			}},
			{path:':id/edit',component:UserEdit,name:'userEdit'}
		]
	},
	{
		path:'/redirect-me',redirect:'/user' //地址为/redirect-me将直接转到/user地址下
	},
	{
		path:'/redirect-you',redirect:{name:'home'} //地址为redirect-you将直接转到/home地址下
	},
	{
		path:'*',redirect:'/' //所有不符合地址规范的都将转到/地址下
	}
];
```

Vue事件修饰符

```
1、事件冒泡（事件不会向上传递） .stop
2、阻止默认事件（不触发默认事件）.prevent
3、指定元素触发（不包括子元素）.self
4、.capture事件默认是双向的，先捕获，在冒泡 .capture
5、绑定事件一次（触发后移除事件）.once

实例上常用的属性
vm.$el 代表的就是获取当前的元素，可以直接操作，修改样式等
vm.$data 获取当前实例上挂载的数据
vm.$options 当前实例上自定的属性
vm.$watch 监控数据的变化 vm.$watch('total',function(newVal,oldVal){})//只要是data上的数据或者计算属性皆可以监控。
```

###### 栅格系统原理

```
栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 .col-md-* 栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 .col-lg-* 不存在， 也影响大屏幕设备。

https://www.cnblogs.com/kidney/p/5351133.html
--------------------- 
作者：杨四郎2018 
来源：CSDN 
原文：https://blog.csdn.net/yang5726685/article/details/68957307 
版权声明：本文为博主原创文章，转载请附上博文链接！

```

###### 包装对象

```javascript
主要是因为在基本类型中，有三个比较特殊的存在就是：String Number Boolean，这三个基本类型都有自己对应的包装对象。并且随时等候召唤。包装对象呢，其实就是对象，有相应的属性和方法。至于这个过程是怎么发生呢，其实是在后台偷偷发生的。

引用类型和基本包装对象的区别在于：生存期

引用类型所创建的对象，在执行的期间一直在内存中，而基本包装对象只是存在了一瞬间。

所以我们无法直接给基本类型添加方法：

//我们平常写程序的过程：
var str = 'hello'; //string 基本类型
var s2 = str.charAt(0); //在执行到这一句的时候 后台会自动完成以下动作 ：
（ 
 var str = new String('hello'); // 1 找到对应的包装对象类型，然后通过包装对象创建出一个和基本类型值相同的对象
 var s2 = str.chaAt(0); // 2 然后这个对象就可以调用包装对象下的方法，并且返回结给s2.
 str = null;  //    3 之后这个临时创建的对象就被销毁了， str =null; 
 ） 
alert(s2);//h 
alert(str);//hello     注意这是一瞬间的动作 实际上我们没有改变字符串本身的值。就是做了下面的动作.这也是为什么每个字符串具有的方法并没有改变字符串本身的原因。
------------------------------------------------------------------------------------------------
var str = 'hello';
str.number = 10; //假设我们想给字符串添加一个属性number ，后台会有如下步骤
｛ 
 var str = new String('hello'); // 1 找到对应的包装对象类型，然后通过包装对象创建出一个和基本类型值相同的对象
  str.number = 10; // 2 通过这个对象调用包装对象下的方法 但结果并没有被任何东西保存
 str =null; // 3 这个对象又被销毁
 ｝
alert(str.number); //undefined  当执行到这一句的时候，因为基本类型本来没有属性，后台又会重新重复上面的步骤
｛ 
 var str = new String('hello'); // 1 找到基本包装对象，然后又新开辟一个内存，创建一个值为hello对象
 str.number = undefined   // 2 因为包装对象下面没有number这个属性，所以又会重新添加，因为没有值，所以值是未定 ;然后弹出结果
 str =null; // 3 这个对象又被销毁
 ｝
```

页面首屏优化

```javascript
1、尽可能的缩小webpack或者其他打包工具生成的包的大小 npm install --save-dev webpack-bundle-analyzer
2、使用服务端渲染的方式
3、使用预渲染的方式
4、使用gzip减小网络传输的流量大小
5、按照页面或者组件分块懒加载

https://blog.csdn.net/clark_fitz817/article/details/79513046#1
```

前端权限管理

```
https://www.cnblogs.com/qianduantuanzhang/archive/2018/01/05/8204692.html
```

虚拟DOM

```
vdom可以看作是一个使用javascript模拟了DOM结构的树形结构，这个树结构包含整个DOM结构的信息，

```

###### base64加密

```javascript
// 创建Base64对象
var Base64 = {
 _keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
 encode: function(e) {
  var t = "";
  var n, r, i, s, o, u, a;
  var f = 0;
  e = Base64._utf8_encode(e);
  while (f < e.length) {
   n = e.charCodeAt(f++);
   r = e.charCodeAt(f++);
   i = e.charCodeAt(f++);
   s = n >> 2;
   o = (n & 3) << 4 | r >> 4;
   u = (r & 15) << 2 | i >> 6;
   a = i & 63;
   if (isNaN(r)) {
    u = a = 64
   } else if (isNaN(i)) {
    a = 64
   }
   t = t + this._keyStr.charAt(s) + this._keyStr.charAt(o) + this._keyStr.charAt(u) + this._keyStr.charAt(a)
  }
  return t
 },
 decode: function(e) {
  var t = "";
  var n, r, i;
  var s, o, u, a;
  var f = 0;
  e=e.replace(/[^A-Za-z0-9+/=]/g,"");
  while (f < e.length) {
   s = this._keyStr.indexOf(e.charAt(f++));
   o = this._keyStr.indexOf(e.charAt(f++));
   u = this._keyStr.indexOf(e.charAt(f++));
   a = this._keyStr.indexOf(e.charAt(f++));
   n = s << 2 | o >> 4;
   r = (o & 15) << 4 | u >> 2;
   i = (u & 3) << 6 | a;
   t = t + String.fromCharCode(n);
   if (u != 64) {
    t = t + String.fromCharCode(r)
   }
   if (a != 64) {
    t = t + String.fromCharCode(i)
   }
  }
  t = Base64._utf8_decode(t);
  return t
 },
 _utf8_encode: function(e) {
  e = e.replace(/rn/g, "n");
  var t = "";
  for (var n = 0; n < e.length; n++) {
   var r = e.charCodeAt(n);
   if (r < 128) {
    t += String.fromCharCode(r)
   } else if (r > 127 && r < 2048) {
    t += String.fromCharCode(r >> 6 | 192);
    t += String.fromCharCode(r & 63 | 128)
   } else {
    t += String.fromCharCode(r >> 12 | 224);
    t += String.fromCharCode(r >> 6 & 63 | 128);
    t += String.fromCharCode(r & 63 | 128)
   }
  }
  return t
 },
 _utf8_decode: function(e) {
  var t = "";
  var n = 0;
  var r = c1 = c2 = 0;
  while (n < e.length) {
   r = e.charCodeAt(n);
   if (r < 128) {
    t += String.fromCharCode(r);
    n++
   } else if (r > 191 && r < 224) {
    c2 = e.charCodeAt(n + 1);
    t += String.fromCharCode((r & 31) << 6 | c2 & 63);
    n += 2
   } else {
    c2 = e.charCodeAt(n + 1);
    c3 = e.charCodeAt(n + 2);
    t += String.fromCharCode((r & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
    n += 3
   }
  }
  return t
 }
}
// 定义字符串
var string = JSON.stringify([1,2,3,4]);

// 加密
var encodedString = Base64.encode(string);
console.log(encodedString); // 输出: "SGVsbG8gV29ybGQh"
// 解密
var decodedString = Base64.decode(encodedString);
console.log(decodedString); // 输出: "Hello World!"
```

###### 存取Cookie

```javascript
 //设置COOKIES
    SetCookie(name, value, day) {
      var date = new Date();
      date.setDate(date.getDate() + day);
      document.cookie =
        name + "=" + encodeURIComponent(value) + ";expires=" + date;
      this.getCookie("park");
    };
 //获取COOKIES
    getCookie(name) {
      var reg = RegExp("park" + "=([^;]+)");
      var arr = document.cookie.match(reg);

      if (arr) {
        return JSON.parse(decodeURIComponent(arr[1]));
      } else {
        return "";
      }
    };
 //删除COOKIES的函数
    delCookie(name) {
      this.SetCookie(name, null, -1);
    };
        
```

###### Vue父子路由的传值

```javascript
//父路由使用provide
provide() {
    return {
      reload: this.reload,
      getUserInformation:this.getUserInformation,
      editID:this.editID
    }
  }

//子路由使用inject  通过数组接收和下面调用
inject:['getUserInformation','reload','editID'],
```

###### Vue项目webpack代理解决跨域

```javascript
// see http://vuejs-templates.github.io/webpack for documentation.
var path = require('path')

module.exports = {
  build: {
    env: require('./prod.env'),
    index: path.resolve(__dirname, '../dist/index.html'),
    assetsRoot: path.resolve(__dirname, '../dist'),
    assetsSubDirectory: 'static',
    assetsPublicPath: './',
    productionSourceMap: false,//是否生成map文件-----------------------------------------
    // Gzip off by default as many popular static hosts such as
    // Surge or Netlify already gzip all static assets for you.
    // Before setting to `true`, make sure to:
    // npm install --save-dev compression-webpack-plugin
    productionGzip: false,//是否使用压缩-----------------------------------------
    productionGzipExtensions: ['js', 'css'],
    // Run the build command with an extra argument to
    // View the bundle analyzer report after build finishes:
    // `npm run build --report`
    // Set to `true` or `false` to always turn it on or off
    bundleAnalyzerReport: process.env.npm_config_report
  },
  dev: {
    env: require('./dev.env'),
    port: 8089,
    autoOpenBrowser: true,
    assetsSubDirectory: 'static',
    assetsPublicPath: '/',
    proxyTable: {//这里就是核心代码----------------------------------------
      '/api':{
        target: "http://zhcl.4000750222.com:8081/testzhclm/",
        changeOrigin:true,
        pathRewrite:{
            '^/api':'api/'
        }
    }
    },
    // CSS Sourcemaps off by default because relative paths are "buggy"
    // with this option, according to the CSS-Loader README
    // (https://github.com/webpack/css-loader#sourcemaps)
    // In our experience, they generally work as expected,
    // just be aware of this issue when enabling this option.
    cssSourceMap: false
  }
}

```

###### Vue项目解决首次加载慢

```javascript
1.使用路由懒加载 ()=>import('./compoent/PieChart').then()；
	component: resolve => require(['./views/Park/user/userControl/usercontrol.vue'], resolve)
2.CDN引入项目依赖 //注意 一定要先引入vue.js
3.组件异步引入
        components: {
            PieChart:()=>import('./compoent/PieChart').then(),
            LineChart:()=>import('./compoent/LineChart').then(),
            ColumnarChart:()=>import('./compoent/ColumnarChart').then()
          },


```

###### Vue路由中的自定义属性

```javascript
//meta中放置自定义属性 
{
                                path:'/park/user/cardetails',
                                component: resolve => require(['./views/Park/user/commonality/userCarDetails.vue'], resolve),
                                name: '用户车辆详情',
                                parent: '用户车辆',
                                meta: {
                                    keepAlive: false,
                                    parent: '用户车辆和用户管理',
                                }
                            },
```

###### 获取当前电脑ip

```javascript
function getUserIP(onNewIP) { //  onNewIp - your listener function for new IPs
      //compatibility for firefox and chrome
      var myPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
      var pc = new myPeerConnection({
         iceServers: []
     }),
     noop = function() {},
     localIPs = {},
     ipRegex = /([0-9]{1,3}(\.[0-9]{1,3}){3}|[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7})/g,
     key;
 
     function iterateIP(ip) {
         if (!localIPs[ip]) onNewIP(ip);
         localIPs[ip] = true;
    }
 
      //create a bogus data channel
     pc.createDataChannel("");
 
     // create offer and set local description
     pc.createOffer().then(function(sdp) {
         sdp.sdp.split('\n').forEach(function(line) {
             if (line.indexOf('candidate') < 0) return;
             line.match(ipRegex).forEach(iterateIP);
         });
         
         pc.setLocalDescription(sdp, noop, noop);
     }).catch(function(reason) {
         // An error occurred, so handle the failure to connect
     });
 
     //sten for candidate events
     pc.onicecandidate = function(ice) {
         if (!ice || !ice.candidate || !ice.candidate.candidate || !ice.candidate.candidate.match(ipRegex)) return;
         ice.candidate.candidate.match(ipRegex).forEach(iterateIP);
     };
}
// Usage
getUserIP(function(ip){
     alert("Got IP! :" + ip);
});
```

###### base64图片

```javascript
 <img :src="'data:image/png;base64,'+photobase64"  alt>
```

##### vue-cli路由打包模块名称修改

```javascript
component:()=>import(/* webpackChunkName: "one" */ '../src/components/two')
```

##### 利用math.js解决js计算精度问题

```javascript
 <script src="https://cdn.bootcss.com/mathjs/6.2.1/math.min.js"></script>
  <script>
    function printFn(value) {
        const precision = 14
        return Number(math.format(value, precision))
    }
    console.log(printFn((0.1+0.2)*10));
  </script>  

//0.1＋0.2
//math.format(math.chain(math.bignumber(0.1)).add(math.bignumber(0.2)).done());

//0.2-0.1
//math.format(math.chain(math.bignumber(0.2)).subtract(math.bignumber(0.1)).done());

//0.1*0.2
//math.format(math.chain(math.bignumber(0.1)).multiply(math.bignumber(0.2)).done());

//0.1/0.2
//math.format(math.chain(math.bignumber(0.1)).divide(math.bignumber(0.2)).done());
//————————————————
//版权声明：本文为CSDN博主「CherryLee_1210」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出   处链接及本声明。
//原文链接：https://blog.csdn.net/CherryLee_1210/article/details/80805681
```

##### axios请求后生成文件

```javascript
 axios({
            url: "zuulPersonnel/personnel/person/download",
            method: "get",
            responseType: "blob",
            transformRequest: this.transformRequest,
            params: {
              idcards: arr.join(","),
              workId: store.workerId,
              ids:arr2.join(',')
            }
          }).then(res => {
            this.butload = false;
            var blob = new Blob([res.data], {
              type:
                "application/vnd.openxmlformats-officedocument.wordprocessingml.document;charset=utf-8"
            });
            var contentDisposition = res.headers["content-disposition"];
            var patt = new RegExp("filename=([^;]+\\.[^\\.;]+);*");
            var result = patt.exec(contentDisposition);
            if (result) {
              var filename = result[1];
              var downloadElement = document.createElement("a");
              var href = window.URL.createObjectURL(blob); //创建下载的链接
              downloadElement.style.display = "none";
              downloadElement.href = href;
              downloadElement.download = filename; //下载后文件名
              document.body.appendChild(downloadElement);
              downloadElement.click(); //点击下载
              document.body.removeChild(downloadElement); //下载完成移除元素
              window.URL.revokeObjectURL(href); //释放掉blob对象
            } else {
              var reader = new FileReader();
              reader.onload = e => {
                var message = JSON.parse(e.target.result).message;
                this.$message.error(message);
                // if (message == "查询员工合同数据为空") {
                //   this.$message.error("生成合同失败，请设置合同");
                // } else if (message == "查询员工班次数据为空") {
                //   this.$message.error("生成合同失败，请添加排班");
                // } else {
                //   this.$message.error("生成合同失败，请检查");
                // }
              };
              reader.readAsText(blob);
            }
          });
```

##### 纯css多行文本溢出省略号

```css
  p{position: relative; line-height: 20px; max-height: 40px;overflow: hidden;width: 600px}
p:after{content: "..."; position: absolute; bottom: 0; right: 0; padding-left: 40px;
background: -webkit-linear-gradient(left, transparent, #fff 55%);
background: -o-linear-gradient(right, transparent, #fff 55%);
background: -moz-linear-gradient(right, transparent, #fff 55%);
background: linear-gradient(to right, transparent, #fff 55%);
}

//渐变是因为最后一个字可能会挤掉一个省略号的点

<p>是颠三倒四都是多所多是颠三倒四都是多所多是颠三倒四都是多所多是颠三倒四都是多所多是颠三倒四都是多所多是颠三倒四都是多所多是颠三倒四都是多所多是颠三倒四都是多所多</p>
```

#### Mysql 8.版本的链接

```javascript
第一种解决方式
node 连接mysql报错'08004'的问题
//Client does not support authentication protocol requested by server; consider upgrading   MySQL client
找了很久的问题，原因是没有配置数据库初始密码，在mysql命令行执行以下命令即可
//ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '你的密码';
//SELECT plugin FROM mysql.user WHERE User = 'root';

第二种还没试过
MySQL8.0版本的加密方式和MySQL5.0的不一样，连接会报错。 
解决方法如下：

通过命令行进入解压的mysql根目录下。
登陆数据库 
//mysql -uroot -p
输入root的密码 
//Enter password: ******
更改加密方式 
//mysql> ALTER USER 'root'@'localhost' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER;
更改密码：该例子中 123456为新密码 
//mysql> ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';
刷新： 
//mysql> FLUSH PRIVILEGES;

/如果报错ERROR 1396 (HY000): Operation ALTER USER failed for ‘root’@’%’： 
则是远程访问权限不正确，先选择数据库，查看一下再更改：

mysql> use mysql;
Database changed

mysql> select user,host from user;
+------------------+-----------+
| user             | host      |
+------------------+-----------+
| mysql.infoschema | localhost |
| mysql.session    | localhost |
| mysql.sys        | localhost |
| root             | localhost |
+------------------+-----------+
5 rows in set (0.00 sec)

```

#### Node path路径

```javascript
var path = require('path')

path.basename("c:/a/b/c/d/index.js")
//index.js

path.basename("c:/a/b/c/d/index.js",'.js')
//'index'

path.basename("c:/a/b/c/d/index.js",'.html')
//'index.js'

path.dirname("c:/a/b/c/d/index.js")
//'c:/a/b/c/d'

path.extname("c:/a/b/c/d/index.js")
//'.js'

path.isAbsolute("c:/a/b/c/d/index.js")
//true

path.isAbsolute("a/b/c/d/index.js")
//false

path.isAbsolute("./a/b/c/d/index.js")
//false

path.isAbsolute("/a/b/c/d/index.js")
//true

path.parse("/a/b/c/d/index.js")
// { root: '/',
//   dir: '/a/b/c/d',
//   base: 'index.js',
//   ext: '.js',
//   name: 'index' }

path.join('c:/a/','b')
//'c:\\a\\b'

node中的`__dirname`指的是当前文件执行的绝对目录(__filename是动态的文件路径)；
path.resolve(__dirname,'../index.html')
//这里的`__dirname`指的是`C:\Users\Administrator\Desktop\node `
//那么path.resolve(__dirname,'../index.html')则为 C:\Users\Administrator\Desktop\index.html

```

#### 前端生成二维码插件

````html
 npm install easyqrcodejs //安装依赖

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <div id="qrcode"></div>
    <script src="./node_modules//_easyqrcodejs@3.2.0@easyqrcodejs/dist/easy.qrcode.min.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript">
	// Options
	var options = {
		text: "https://tool.lu/timestamp/"
	};
	
	// Create QRCode Object
	new QRCode(document.getElementById("qrcode"), options);
</script>
</body>
</html>




````

#### 正则验证车牌号（含新能源）

```javascript
// 综合处理（普通汽车+新能源）
function verifyLicensePlateNum (value) {
    const express = /^([京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[a-zA-Z](([DF]((?![IO])[a-zA-Z0-9](?![IO]))[0-9]{4})|([0-9]{5}[DF]))|[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1})$/;
    const result = express.test(value);
    return result;
}
————————————————
版权声明：本文为CSDN博主「初心-杨瑞超个人博客」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_42817227/article/details/93179630
```

#### ES5实现继承

```js
//继承
      function Father(name, age){
        //this 指向 Son的实例对象son
        this.name = name;
        this.age = age;
      }
      Father.prototype.money = 1000;
      
      function Son(name,age) { 
          Father.call(this,name,age);//改变this指向
      }

      Son.prototype = new Father();//Son的原型对象重新赋值实现继承
      Son.prototype.constructor = Son ;//如果没这样做 Son构造函数的构造器指向了Father //Son还需要                                          有自己的属性和方法 所以这样做
      Son.prototype.learn = '学习'

      var son = new Son('李博',26);

      console.log(son);//{name: "李博", age: 26}
      console.log(Father.prototype);//{money: 1000, constructor: ƒ}
```



#### 生成图片后下载

~~~html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <button id="hehe">点我</button>
    <div id="haha" style="width: 261px;">
        <div style="background: red;">6666</div>
        <div id="qrcode" style="width: 261px;height:261px"></div>
    </div>
    <!-- <img class="imgDiv_img"> -->
    <!-- <div id="Download"></div> -->
    <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
    <script src="https://cdn.bootcss.com/html2canvas/0.5.0-beta4/html2canvas.min.js"></script>
    <script src="./node_modules/easyqrcodejs/dist/easy.qrcode.min.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript">
	  var saveFile = function(data, filename) {
        var save_link = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');
        save_link.href = data;
        save_link.download = filename;
        var event = document.createEvent('MouseEvents');
        event.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
        save_link.dispatchEvent(event);
    };
	var options = {
		text: "http://localhost:8090"
	};
    var imgUri;
	// Create QRCode Object
    new QRCode(document.getElementById("qrcode"), options);
    html2canvas(document.getElementById("haha")).then(function(canvas) {
        imgUri = canvas.toDataURL("image/png").replace("image/png", "image/octet-stream"); // 获取生成的图片的url
        $(".imgDiv_img").attr("src",imgUri);
        
    });
    hehe.onclick = function () { 
        saveFile(imgUri, 'abc.png');
     }      
</script>
</body>
</html>
~~~

#### 图片base64转文件

~~~js
   function base64TransFile(base64Url,fileName){ 
    ////将图片Base64 转成文件
    var arr = base64Url.split(','),
        mime = arr[0].match(/:(.*?);/)[1],
        str = atob(arr[1]),
        n = str.length,
        u8arr = new Uint8Array(n);
    while (n--) {
      u8arr[n] = str.charCodeAt(n);
    }
    return new File([u8arr], fileName, { type: mime });
  }
~~~

#### url的img图片复制到粘贴板

~~~html
<div>
  <img src="http://img0.bdstatic.com/static/searchresult/img/logo-2X_b99594a.png" alt="pic">
  <p>尝试拖动图片至word</p>
  <p>点击我再粘贴试试</p>
</div>
<script>
	const getSelect = targetNode => {
  if (window.getSelection) {
    //chrome等主流浏览器
    var selection = window.getSelection();
    var range = document.createRange();
    range.selectNode(targetNode);
    selection.removeAllRanges();
    selection.addRange(range);
  } else if (document.body.createTextRange) {
    //ie
    var range = document.body.createTextRange();
    range.moveToElementText(targetNode);
    range.select();
  }
}
const clipboardHandler = (nodeName, event) => {
	event = event || nodeName; //不传参时
  const type = Object.prototype.toString.call(nodeName).replace(/\[object\s|\]/g, '');
  const target = event.target || event.srcElement;

  var result = false;
  switch (type) {
    case 'String':
      result = (target.nodeName.toLowerCase() === nodeName);
      break;
    case 'Array':
      result = nodeName.some(item => target.nodeName.toLowerCase() === item);
      break;
    case 'Object':
      nodeName = null;
    default:
      result = (target.nodeName === 'IMG');
  }
  if (result) {
    getSelect(target);
    document.execCommand('copy');
  }
}

//绑定事件
var img = document.querySelectorAll("img")[0];
img.addEventListener('mouseenter', clipboardHandler);

var pHandler = clipboardHandler.bind(null, 'p');
var div = document.querySelectorAll("div")[0];
div.addEventListener('click', pHandler);
</script>
~~~

#### 检测图片尺寸大小

~~~js
 const isSize = new Promise(function(resolve, reject) {
        let width = 245;
        let height = 107;
        let _URL = window.URL || window.webkitURL;
        let img = new Image();
        img.onload = function() {
          let valid =typeof obj==='object'?(img.width ==obj.width && img.height == obj.height):obj;
          valid ? resolve() : reject();
        };
        img.src = _URL.createObjectURL(file);
~~~

#### url输入后都发生了什么

~~~html
注意：本文的步骤是建立在，请求的是一个简单的 HTTP 请求，没有 HTTPS、HTTP2、最简单的 DNS、没有代理、并且服务器没有任何问题的基础上，尽管这是不切实际的。

大致流程：URL解析 - DNS查询 - TCP连接 - 处理请求 - 接受响应 - 渲染页面

~~~

#### webpack路由生成

~~~js
var a = require.context('../views',true,/\.(vue|js)$/);
console.log(a.keys());
~~~

## Vue虚拟滚动插件

~~~html
<template>
  <div class="dynamic-scroller-demo">
    <img src="ddd" alt="" @error="err">
    <DynamicScroller
      :items="items"
      :min-item-size="54"
      class="scroller"
    >
      <template v-slot="{ item, index, active }">
        <DynamicScrollerItem
          :item="item"
          :index="index"
          :active="active"
          :data-index="index"
          :data-active="active"
          class="message"
        >
          <div class="text">
            {{ item }}
          </div>
          <div class="index">
            <span>{{ index }} (index)</span>
          </div>
        </DynamicScrollerItem>
      </template>
    </DynamicScroller>
  </div>
</template>

<script>
export default {
  data () {
    return {
      items:new Array(500).fill('哈哈哈'),
      search: '',
      dynamic: true,
    }
  },
  methods:{
    err(ev){
      console.log(111,ev);
    }
  },
mounted() {
 
},
}
</script>

<style scoped>
.scroller {
  height: 500px;
}
</style>

~~~

#### xlsx解析文件

~~~js
import XLSX from 'xlsx';   	
const reader = new FileReader()
	    reader.onload = function(e) {
	      const data = e.target.result
	      var wb = XLSX.read(data, {
	        type: 'binary'
	      })
	      const result = []
	      wb.SheetNames.forEach((sheetName) => {
	        result.push({
	          sheetName: sheetName,
	          sheet: XLSX.utils.sheet_to_json(wb.Sheets[sheetName])
	        })
        })
        console.log(result)
	    }
      reader.readAsBinaryString(file)
~~~

