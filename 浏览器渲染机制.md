

 #  浏览器渲染机制

一道面试题引发的血案，从用户浏览器地址栏输入url地址到点击回车发生了什么？

```js
1.什么是进程和线程
//电脑每打开一个程序就是一个进程，每一个程序里面要很多操作，就是线程（线程是进程的子任务）。
```

![1581580698614](D:\学习笔记\img\1581580698614.png)

![1581580775507](D:\学习笔记\img\1581580775507.png)

![1581580912269](D:\学习笔记\img\1581580912269.png)

```js
2.客户端和服务端的连接
//（1）.客户端请求服务端
//DNS解析---TCP三次握手和四次挥手（还要注意http1和http2的区别）
//（2）.服务端返回相应和数据给客户端
//HTTP状态码，HTTP报文（记得性能优化的304缓存），然后客户端浏览器拿到返回的代码字   符串。拿到代码后浏览器在内存中开辟出一块栈内存，用来给代码的执行提供话环境，同时   分配一个主线程去一行行解析和执行代码（js单线程就是因为浏览器只会分配一个线程去   干这个活），执行代码首先要进栈执行（<!DOCTYPE html>告诉浏览器文档类型，告诉他   去如何解析代码），执行一行，执行完之后出栈再去执行下一行，当浏览器遇到link,script，img等请求后都会开辟全新的线程去加载资源文件（浏览器是多线程程序，但他只分配了一个进程去执行代码），请求资源文件会开辟一个新的空间叫做任务队列（task queue）去执行资源文件任务，此时主进程继续逐行执行下面的代码，第一次从上到下走完代码会生成DOM树（在生成DOM树之前css等资源文件还没有回来），光有DOM树页面渲染还没完成，此时主线程会去任务队列去看有没有执行完的任务，有执行完的依次一个一个拿到主进程去执行然后再去任务队列拿（这就是事件循环 event loop，只有一个线程来回拿和取，事件循环还是单线程，任务里面分为微任务和宏任务），CSS处理完成生成CSSOM，然后CSSOM和DOM会进行结合生成render tree （渲染树)这里开始才一切准备就绪，电脑这时用显卡GPU来根据渲染树是一点一点绘制图像才能显示页面。
```

![1581584395625](D:\学习笔记\img\1581584395625.png)

![1581585192152](D:\学习笔记\img\1581585192152.png)

```js
//回流一定会发生重绘，因为重绘是回流之后必须执行的步骤，虚拟dom和dom diff算法大限度的减少了回流和重绘，所以性能相对好很多。
//当代浏览器有渲染队列机制（老浏览器没有），假如你连续操作一个元素的style，它会等你连续完执行代码之后一起去回流和重绘这个元素，也就是说浏览器本身就帮你做了一些优化，如果连续修改样式中间出现类型（console。log（元素.offsetTop）等操作会终止队列机制，就是说中断了浏览器的优化，然后回流或重绘一此，所以要记得读写分离）
//样式集中改变也可以减少回流和重绘
//缓存处理减少回流和重绘： let a = box.clientWidth;
            let b = box.clientHeight;
		    box.style.width = a + 10 + 'px';
		    box.style.width = b + 10 + 'px';
//使用文档碎片或者字符串拼接也会节省回流和重绘（doc.innerHTML = `${123}`）
```

![1581585542265](D:\学习笔记\img\1581585542265.png)

# Promise记录

~~~js
Promise对象有以下两个特点。

（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。

（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。

Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

如果某些事件不断地反复发生，一般来说，使用 Stream 模式是比部署Promise更好的选择。

//------------------------------------------------------------
const p1 = new Promise(function (resolve, reject) {
  setTimeout(() => reject(new Error('fail')), 3000)
})

const p2 = new Promise(function (resolve, reject) {
  setTimeout(() => resolve(p1), 1000)
})

p2
  .then(result => console.log(result))
  .catch(error => console.log(error))
// Error: fail

上面代码中，p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。

注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。
//------------------------------------------------------------------

new Promise((resolve, reject) => {
  resolve(1);
  console.log(2);
}).then(r => {
  console.log(r);
});
// 2
// 1
上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。
//--------------------------------------------------------

一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。

new Promise((resolve, reject) => {
  return resolve(1);
  // 后面的语句不会执行
  console.log(2);
})
//-------------------------------------------------------------------

Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。

getJSON('/post/1.json').then(function(post) {
  return getJSON(post.commentURL);
}).then(function(comments) {
  // some code
}).catch(function(error) {
  // 处理前面三个Promise产生的错误
});
//-------------------------------------------------------------------
~~~

# V8引擎如何回收内存

![1581674480316](D:\学习笔记\img\1581674480316.png)![1581674514936](D:\学习笔记\img\1581675850921.png)

![1581676471196](D:\学习笔记\img\1581676471196.png)

~~~js
1.为什么要把内存定为1.4G？
答：（1）js设计之初是为了浏览器，前端的特点——不持久化，执行一遍就全部会回收，1.4G是完全够用的。
    （2）js回收内存的时候，会暂停执行，回收可能需要几毫秒的时间。
2.垃圾回收算法
答：新生代简单地说就是复制，老生代就是标记删除整理。//（新生代内存分为两块from和to，新生代用来存放一些新产生的变量，老生代是用来放那些新生代觉得有些变量符合老生代了，就把这些变量放到老生代，新生代适合放那些比较小比较新的变量，新生代的两块是互相使用的 这一次他是form，下次就是to，在下次又变成了from，另外一块反之，把里面的变量来回复制，牺牲了空间去换时间，就新生代的两块来回倒换，）//（老生代不能采用空间换时间，因为老生代占内存比新生代大很多，牺牲空间很不好，1400MB一半就是700MB很大，老生代中黑色的部分就是已经失去引用死掉的变量，内存会把死掉的变量标记上，回收的时候就是回收标记的变量，死掉的变量删除后位置就会空，所以还会有一步整理操作，就像平时的磁盘整理工作，白块会逐个向前移动，留下的空间放在一起，让内存连续起来，就比如说数组，数组是有序且连续的，如果不整理，数组放在内存中顺序会乱，可能会无法定义）
3.新生代如何晋升到老生代？
答：条件1：当新生代空间的from和to来回倒换互相使用的时候，会判断这个变量是否回收过，是的话就放到老生             代，不是就去to空间。
    条件2：当新生代空间的from和to来回倒换互相使用的时候，判断to空间是否已经使用了25%，是的话去老生              代，不是的话就去to空间。
~~~

![1581677237844](D:\学习笔记\img\1581677237844.png)

# let const

![1581685820987](D:\学习笔记\img\1581685820987.png)![1581686090010](D:\学习笔记\img\1581686090010.png)

# 堆栈内存机制

![1581777258569](D:\学习笔记\img\1581777258569.png)